# Карманный справочник по TypeScript
ссылка на ресурс - https://typescript-handbook.ru/docs/intro/
---

TS это инструмент проверки статических типов. Системы статических типов описывают форму и поведение значений. TS использует эту информацию и сообщает нам, что возможно имеет место несоотвествие описанных типов.

Зачем же нужны типы? Типы данных используются для добавления статических ограничений на программные элементы, такие как функции, переменные и свойства. Это позволяет компилятору и средствам разработки осуществлять более тщательную проверку и поддержку в процессе разработки.
## Анотация типов
---
+ any
+ boolean
+ number
+ bigint
+ string
+ void
+ never(для выброса ошибок или бескон. цикл)
+ null
+ undefined
+ Symdol

> При вызове `const test = Symbol()` не нужно прописывать тип, он автоматом подтягивается с возвращаемого объекта Symbol.

## Структуры(составной тип данных)
---
Обычно в TypeScript не разделяют понятия типа и структуры, потому что структура тоже является типом. Но так как структура – это составной тип данных, который состоит из разных типов, сгруппированных под одним, мы выделили такие типы в отдельную часть.

+ Array<>/ [ ]
+ Tuple
+ Enum

> Благодаря ts мы можем создавать массив из колекции однородных данных. Плюс ко всему, мы можем так сделать массив только для чтения `readonly string[]`

> Тип Tuple или кортеж представляет собой массив, каждому из элементов которого можно указать свой тип. Обычно такая структура используется для предоставления набора данных, например, записи в базе данных.

## Операторы для работы с типами
---
+ typeof

Механизм запроса типа Type Queries позволяет получить тип, связанный со значением по его идентификатору и в дальнейшим использовать его как обычный тип. То есть мы можем забирать типы с переменных.
```
let isVar1: string
let isVar2: typeof isVar1
```

+ Union (" | ")

Механизм, позволяющий создавать из множества существующих типов логическое условие, по которому данные могут принадлежать только к одному из указанных типов.
```
let isUnion: string | number | boolean
```

+ Intersection (" & ") перевод - пересечение

Механизм TypeScript, который позволяет рассматривать множество типов данных как единое целое.
```
interface Colorful {
  color: string
}
interface Circle {
  radius: number
}

function draw(circle: Colorful & Circle) {
  console.log(`Color was ${circle.color}`)
  console.log(`Radius was ${circle.radius}`)
}

draw({ color: 'blue', radius: 42 })
draw({ color: 'red', raidus: 42 }) // тут ошибка, неправильно написано свойство raidus
```
Очень удобно можно расширять псевдонимы.
```
type Person = {name: string; age: number};
type User = Person & {location: string;}
```
+ type

Для любого типа можно создать его псевдоним и использовать его в дальнейшем. Псевдоним типа объявляется при помощи ключевого слова type. Стоит помнить, что при указание созданного пользовательского типа, нельзя добавлять новые свойства, что нельзя сказать про interface, там можно в объект в рантайме закибывать новые свойства и компилятор ничего не скажет про это. Зато типы можно объединять с помощью & , а с interface придеться наследоваться.

+ as

Тип assertion представляет модель преобразования значения переменной к определенному типу. Обычно в некоторых ситуациях одна переменная может представлять какой-то широкий тип, например any, который по факту допускает значения различных типов. Однако при этом нам надо использовать переменную как значение строго определенного типа. И в этом случае мы можем привести к этому типу. Есть две формы приведения.
```
let isAny: any = 777 // Обычно переменная isAny можем быть перечнем разных типов.
let isNumber = isAny as number // Но в данном случаи мы хотим чтобы чейчас она была типа number, что использовать все возможности данного типа
console.log(isNumber + ', Тип: ' + typeof isNumber)
```
Или вот, вот тут функция, может принять разные пользовательские типы, но на выходе мы должны знать, какой именно ты вернули, но тут as нас спасает
```
type User = {
    name: string,
    age: number,
    isOnline: boolean
}
type Admin = {
    name: string,
    age: number,
    role: boolean
}
type Person = User | Admin;

function logInfo(obj: Person) {
    if('isOnline' in obj) {
        return obj as User
    }
    return obj as Admin
}
```
С помощью as const мы можем создать Tuple. пример
```
const list = ['vlad', 45] as const;
// равносильно 
const list: readonly [string, number] = ['vlad', 45];
```
+ is

sdf
+ keyof

Если стоит задача собрать все ключи у какого-то типа, то оператор keyof с этим справиться. Плюс стоит отметить, что keyof возврщает не массив ключей как в JS, а возвращает объединение литералов ключей.
```
interface ILikesButton {
	className: string;
	count: number;
	size: 'X', 'M', 'S';
}

type keysLikesBtn = keyof ILikesButton; // 'className' | 'count' | 'size';
```
+ Readonly Array<string>

Мы можем сделать так, что бы массив был доступен только для чтения, нельзя добавлять или удалять элементы.

## Function
---
Типичное описание функции в TypeScript с определением типа передаваемых параметров и типа возвращаемого значения.

+ 1. Функция должна что-то возвращать(тип или интерфейс) или ничего (по умолчанию :void)
+ 2. В функции можно использовать необязательные парметры((name: string, age?: number) => {})
+ 3. Можно ставить значения по-умолчанию( (name: string = 'noName') => {} )
+ 4. Неопределенный набор аргументов(...Rest: number[]). Так как rest это по факту массив, нужно не забыть указать тип.
+ 5. Перегрузка функции.

!Note:
> TypeScript поддерживает возможность перегрузки функций, то есть мы можем определить несколько версий функции, которые будут иметь одно и то же имя, но разные типы параметров или разное количество параметров. Для перегрузки вначале опеределяем все версии функции, которые не будут иметь никакой логики. А потом определяем версию функции с общей сигнатурой, которая подходит под все ранее определенные варианты. И в этой общей версии уже определяем конкретную логику функции.  
Например, нам надо объединить два значения, но если они представляют строки, то просто их конкатенировать, а если числа - то сложить. Тогда мы могли бы использовать следующую функцию:

```
function add(x: string, y: string): string;
function add(x: number, y: number): number;
function add(x: any, y: any): any {
    return x + y;
}

console.log(add(5, 4));
console.log(add('vlad', 'palaev'));
console.log(add(false, true)); // будет ошибка, так как у нас параметр
```
Первая версия функции add принимает две строки и возвращает строку, вторая версия принимает два числа и возвращает число. Общей для них будет функция, которая принимает параметры типа any и возвращает результат также типа any. 

## Джинерики
---
В основу создание джинериков легка теория переиспользованности.  
Ситуация, когда у нас появляется дублирующий код в интерфейсах.
```
interface likesButton {
    className: string;
    count: number;
    size: 'S' | 'M';
}
interface likesButton {
    className: string;
    count: number;
    size: 'XLL' | 'XS';
}
interface likesButton {
    className: string;
    count: number;
    size: number;
}

interface ILikesButton<T> {
    name: string;
    count: number;
    size: T
}
ILikesButton<'S' | 'XS'>
```
+ Parameters<>  
> Расширенный тип Parameters<T> предназначен для получения типов указанных в аннотации параметров функции. В качестве аргумента типа ожидается функциональный тип, на основе которого будет получен размеченный кортеж описывающий параметры этого функционального типа. Возвращает типы параметров в виде кортежа.

+ ReturnType<typeof Fn>
> Условный тип ReturnType<T> служит для установления возвращаемого из функции типа. В качестве параметра типа должен обязательно выступать функциональный тип.


## Задачки
---
Задача. Реализовать свою функцию джинерика Record<string, number>
```
type Record1<T extends keyof any, K> = {
    [P in T]: K;
}
// keyof any возвращает string | number | Symbol
[P in T]: магия в том, что мы просто говорим, что наши ключи могу быть только одним из перечисленных значений в джинерики T
```
Внутри TS есть своя реализации Record<key, typeValue>
> Record — это более строгий тип объекта. Он тоже использует дженерики, первый аргумент это тип ключа, а второй тип значения.

